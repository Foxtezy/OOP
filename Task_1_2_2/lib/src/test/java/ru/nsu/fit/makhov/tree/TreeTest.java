/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.makhov.tree;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

class TreeTest {

  private Tree<Integer> tree;

  @BeforeEach
  public void setup() {
    tree =
        new Tree<>(
            ((o1, o2) -> (o1 > o2) ? 1 : (o1.equals(o2)) ? 0 : -1), 6, 8, 5, 2, 9, 7, 4, 10, 3, 1);
  }

  @Test
  public void treeDFSTest() {
    tree.setSearch(Tree.Search.DFS);
    assertEquals(Arrays.asList(6, 8, 9, 10, 7, 5, 2, 4, 3, 1), tree.toList());
  }

  @Test
  public void treeBFSTest() {
    tree.setSearch(Tree.Search.BFS);
    assertEquals(Arrays.asList(6, 5, 8, 2, 7, 9, 1, 4, 10, 3), tree.toList());
  }

  @Test
  public void treeRemoveRootTest() {
    tree.remove(6);
    assertEquals(Arrays.asList(7, 5, 8, 2, 9, 1, 4, 10, 3), tree.toList());
  }

  @Test
  public void treeRemoveTwoChildrenNodeTest() {
    tree.remove(8);
    assertEquals(Arrays.asList(6, 5, 9, 2, 7, 10, 1, 4, 3), tree.toList());
  }

  @Test
  public void treeRemoveOneChildrenNodeTest() {
    tree.remove(5);
    assertEquals(Arrays.asList(6, 2, 8, 1, 4, 7, 9, 3, 10), tree.toList());
  }

  @Test
  public void treeAddExistValueTest() {
    tree.add(8);
    assertEquals(Arrays.asList(6, 5, 8, 2, 7, 9, 1, 4, 10, 3), tree.toList());
  }

  @Test
  public void treeConcurrentModificationExceptionTest() {
    Iterator<Integer> itr = tree.iterator();
    itr.next();
    tree.add(-10);
    assertThrows(ConcurrentModificationException.class, itr::next);
  }

  @Test
  public void treeSampleTest() {
    Tree<String> stringTree =
        new Tree<>((o1, o2) -> (o1.compareTo(o2) > 0) ? 1 : (o1.equals(o2)) ? 0 : -1);
    stringTree.add("A");
    stringTree.add("AB");
    stringTree.add("BB");
    assertEquals(
        Arrays.asList("AB", "BB"),
        stringTree.stream().filter(s -> s.contains("B")).collect(Collectors.toList()));
  }

}
